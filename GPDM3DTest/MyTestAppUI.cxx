// generated by Fast Light User Interface Designer (fluid) version 1.0100

#include "MyTestAppUI.h"

inline void MyTestAppInterface::cb_execute_i(Fl_Button*, void*) {
  this->segment();
}
void MyTestAppInterface::cb_execute(Fl_Button* o, void* v) {
  ((MyTestAppInterface*)(o->parent()->user_data()))->cb_execute_i(o,v);
}

inline void MyTestAppInterface::cb_load_i(Fl_Button*, void*) {
  this->LoadImage();
currentslice->value("0");
if (slices > 1) nload->activate();
}
void MyTestAppInterface::cb_load(Fl_Button* o, void* v) {
  ((MyTestAppInterface*)(o->parent()->user_data()))->cb_load_i(o,v);
}

inline void MyTestAppInterface::cb_Display_i(Fl_Button*, void*) {
  this->display();
}
void MyTestAppInterface::cb_Display(Fl_Button* o, void* v) {
  ((MyTestAppInterface*)(o->parent()->user_data()))->cb_Display_i(o,v);
}

Fl_Menu_Item MyTestAppInterface::menu_[] = {
 {"File", 0,  0, 0, 64, 0, 0, 14, 56},
 {"New", 0,  0, 0, 0, 0, 0, 14, 56},
 {"Open", 0,  0, 0, 0, 0, 0, 14, 56},
 {"Save", 0,  0, 0, 0, 0, 0, 14, 56},
 {"Save as", 0,  0, 0, 0, 0, 0, 14, 56},
 {"Close", 0,  0, 0, 0, 0, 0, 14, 56},
 {"Exit", 0,  0, 0, 0, 0, 0, 14, 56},
 {0},
 {"Setting", 0,  0, 0, 64, 0, 0, 14, 56},
 {"Gibbs Model", 0,  0, 0, 0, 0, 0, 14, 56},
 {"Deformable Model", 0,  0, 0, 0, 0, 0, 14, 56},
 {"Seed", 0,  0, 0, 0, 0, 0, 14, 56},
 {0},
 {"Display", 0,  0, 0, 64, 0, 0, 14, 56},
 {0},
 {"Model", 0,  0, 0, 64, 0, 0, 14, 56},
 {"Gibbs", 0,  0, 0, 64, 0, 0, 14, 56},
 {"Run", 0,  0, 0, 0, 0, 0, 14, 56},
 {"Stat", 0,  0, 0, 0, 0, 0, 14, 56},
 {"Save", 0,  0, 0, 0, 0, 0, 14, 56},
 {"Update", 0,  0, 0, 0, 0, 0, 14, 56},
 {0},
 {"Deformable", 0,  0, 0, 64, 0, 0, 14, 56},
 {"Gradient Map", 0,  0, 0, 0, 0, 0, 14, 56},
 {"Gradient Fit", 0,  0, 0, 0, 0, 0, 14, 56},
 {"Balloon Fit", 0,  0, 0, 0, 0, 0, 14, 56},
 {"Comb ined Fit", 0,  0, 0, 0, 0, 0, 14, 56},
 {0},
 {0},
 {0}
};

inline void MyTestAppInterface::cb_Set_i(Fl_Button*, void*) {
  this->setpar();
}
void MyTestAppInterface::cb_Set(Fl_Button* o, void* v) {
  ((MyTestAppInterface*)(o->parent()->user_data()))->cb_Set_i(o,v);
}

inline void MyTestAppInterface::cb_Seed_i(Fl_Light_Button*, void*) {
  this->ClearClicked();
this->PickSeed();
}
void MyTestAppInterface::cb_Seed(Fl_Light_Button* o, void* v) {
  ((MyTestAppInterface*)(o->parent()->user_data()))->cb_Seed_i(o,v);
}

inline void MyTestAppInterface::cb_save_i(Fl_Button*, void*) {
  this->SaveResult();
}
void MyTestAppInterface::cb_save(Fl_Button* o, void* v) {
  ((MyTestAppInterface*)(o->parent()->user_data()))->cb_save_i(o,v);
}

inline void MyTestAppInterface::cb_nload_i(Fl_Button*, void*) {
  this->LoadNextImage(++cslices, m_FileName);
  itoa(cslices, str_slice, 10);
  currentslice->value(str_slice);
}
void MyTestAppInterface::cb_nload(Fl_Button* o, void* v) {
  ((MyTestAppInterface*)(o->parent()->user_data()))->cb_nload_i(o,v);
}

inline void MyTestAppInterface::cb_dsetting_i(Fl_Button*, void*) {
  dfsetting->show();
setgradient->activate();
}
void MyTestAppInterface::cb_dsetting(Fl_Button* o, void* v) {
  ((MyTestAppInterface*)(o->parent()->user_data()))->cb_dsetting_i(o,v);
}

inline void MyTestAppInterface::cb_dfitting_i(Fl_Button*, void*) {
  //viewer->loadnormals(m_dfilter->GetNormals());
//viewer->loadobject(m_meshsource->GetOutput());
//viewer->redraw();
DeformableFit();
dfitting->deactivate();
updatedisplay->activate();
}
void MyTestAppInterface::cb_dfitting(Fl_Button* o, void* v) {
  ((MyTestAppInterface*)(o->parent()->user_data()))->cb_dfitting_i(o,v);
}

inline void MyTestAppInterface::cb_setgradient_i(Fl_Button*, void*) {
  SetGradient();
dfitting->activate();
setgradient->deactivate();
viewer->loadObject(m_dfilter->GetOutput());
viewer->loadNormals(m_dfilter->GetNormals());
viewer->redraw();
//viewer->redraw();
}
void MyTestAppInterface::cb_setgradient(Fl_Button* o, void* v) {
  ((MyTestAppInterface*)(o->parent()->user_data()))->cb_setgradient_i(o,v);
}

inline void MyTestAppInterface::cb_xpan_i(Fl_Slider* o, void*) {
  viewer->panx(((Fl_Slider *)o)->value());
viewer->redraw();
}
void MyTestAppInterface::cb_xpan(Fl_Slider* o, void* v) {
  ((MyTestAppInterface*)(o->parent()->parent()->user_data()))->cb_xpan_i(o,v);
}

inline void MyTestAppInterface::cb_vrot_i(Fl_Roller* o, void*) {
  viewer->h_angle(((Fl_Roller *)o)->value());
viewer->redraw();
}
void MyTestAppInterface::cb_vrot(Fl_Roller* o, void* v) {
  ((MyTestAppInterface*)(o->parent()->parent()->user_data()))->cb_vrot_i(o,v);
}

inline void MyTestAppInterface::cb_ypan_i(Fl_Slider* o, void*) {
  viewer->pany(((Fl_Slider *)o)->value());
viewer->redraw();
}
void MyTestAppInterface::cb_ypan(Fl_Slider* o, void* v) {
  ((MyTestAppInterface*)(o->parent()->parent()->user_data()))->cb_ypan_i(o,v);
}

inline void MyTestAppInterface::cb_hrot_i(Fl_Roller* o, void*) {
  viewer->v_angle(((Fl_Roller *)o)->value());
viewer->redraw();
}
void MyTestAppInterface::cb_hrot(Fl_Roller* o, void* v) {
  ((MyTestAppInterface*)(o->parent()->parent()->user_data()))->cb_hrot_i(o,v);
}

inline void MyTestAppInterface::cb_viewzoom_i(Fl_Value_Slider* o, void*) {
  viewer->size=((Fl_Value_Slider *)o)->value();
viewer->redraw();
}
void MyTestAppInterface::cb_viewzoom(Fl_Value_Slider* o, void* v) {
  ((MyTestAppInterface*)(o->parent()->user_data()))->cb_viewzoom_i(o,v);
}

inline void MyTestAppInterface::cb_ok_i(Fl_Button*, void*) {
  m_Region = regionlimit->value();
m_Radius = radius->value();
m_ClassNum = classnum->value()+1;
m_Gradient = gradient->value();
m_Step = step->value();
gsetting->hide();
return;
}
void MyTestAppInterface::cb_ok(Fl_Button* o, void* v) {
  ((MyTestAppInterface*)(o->parent()->user_data()))->cb_ok_i(o,v);
}

inline void MyTestAppInterface::cb_cancel_i(Fl_Button*, void*) {
  gsetting->hide();
return;
}
void MyTestAppInterface::cb_cancel(Fl_Button* o, void* v) {
  ((MyTestAppInterface*)(o->parent()->user_data()))->cb_cancel_i(o,v);
}

inline void MyTestAppInterface::cb_dfok_i(Fl_Button*, void*) {
  m_Stiffness[0] = vstiffness->value();
m_Stiffness[1] = hstiffness->value();
m_GradientMagnitude = maggradient->value();
m_Scale[0] = scalex->value();
m_Scale[1] = scaley->value();
m_Scale[2] = scalez->value();
m_TimeStep = timestep->value();
m_StepThreshold = stepthreshold->value();
dfsetting->hide();
return;
}
void MyTestAppInterface::cb_dfok(Fl_Button* o, void* v) {
  ((MyTestAppInterface*)(o->parent()->user_data()))->cb_dfok_i(o,v);
}

inline void MyTestAppInterface::cb_dfcancel_i(Fl_Button*, void*) {
  dfsetting->hide();
return;
}
void MyTestAppInterface::cb_dfcancel(Fl_Button* o, void* v) {
  ((MyTestAppInterface*)(o->parent()->user_data()))->cb_dfcancel_i(o,v);
}

MyTestAppInterface::MyTestAppInterface() {
  Fl_Window* w;
  { Fl_Window* o = mainwin = new Fl_Window(750, 551, "Main");
    w = o;
    o->box(FL_DOWN_BOX);
    o->user_data((void*)(this));
    { Fl_Button* o = execute = new Fl_Button(20, 165, 100, 25, "Execute");
      o->callback((Fl_Callback*)cb_execute);
    }
    { Fl_Button* o = load = new Fl_Button(20, 45, 100, 25, "Load");
      o->callback((Fl_Callback*)cb_load);
    }
    { Fl_Button* o = Display = new Fl_Button(20, 205, 100, 25, "Display");
      o->callback((Fl_Callback*)cb_Display);
    }
    { Fl_Menu_Bar* o = new Fl_Menu_Bar(0, 0, 750, 20);
      o->menu(menu_);
    }
    { Fl_Button* o = Set = new Fl_Button(20, 85, 100, 25, "Set");
      o->callback((Fl_Callback*)cb_Set);
    }
    { Fl_Light_Button* o = Seed = new Fl_Light_Button(20, 125, 100, 25, "Pick Seed");
      o->callback((Fl_Callback*)cb_Seed);
    }
    { Fl_Button* o = save = new Fl_Button(20, 245, 100, 25, "Save");
      o->callback((Fl_Callback*)cb_save);
    }
    { Fl_Button* o = nload = new Fl_Button(20, 285, 100, 25, "Load Next");
      o->callback((Fl_Callback*)cb_nload);
      o->deactivate();
    }
    { Fl_Output* o = currentslice = new Fl_Output(45, 510, 95, 25, "Slice:");
      o->box(FL_FLAT_BOX);
      o->color(48);
    }
    { Fl_Box* o = new Fl_Box(15, 40, 110, 275, "Gibbs Fitting");
      o->box(FL_DOWN_FRAME);
      o->align(FL_ALIGN_TOP_LEFT);
    }
    { Fl_Box* o = new Fl_Box(15, 340, 165, 155, "Deformable Fitting");
      o->box(FL_DOWN_FRAME);
      o->align(FL_ALIGN_TOP_LEFT);
    }
    { Fl_Button* o = updatedisplay = new Fl_Button(20, 345, 155, 25, "Update Display");
      o->deactivate();
    }
    { Fl_Button* o = dsetting = new Fl_Button(20, 385, 155, 25, "Deformable Setting");
      o->callback((Fl_Callback*)cb_dsetting);
    }
    { Fl_Button* o = dfitting = new Fl_Button(20, 465, 155, 25, "Deformable Fitting ");
      o->callback((Fl_Callback*)cb_dfitting);
      o->deactivate();
    }
    { Fl_Button* o = setgradient = new Fl_Button(20, 425, 155, 25, "Set Gradient");
      o->callback((Fl_Callback*)cb_setgradient);
      o->deactivate();
    }
    { Fl_Group* o = vcontrol = new Fl_Group(285, 475, 325, 60, "vcontrol");
      o->align(FL_ALIGN_CENTER);
      { Fl_Slider* o = xpan = new Fl_Slider(310, 485, 275, 20, "xpan");
        o->type(5);
        o->box(FL_PLASTIC_DOWN_BOX);
        o->labeltype(FL_NO_LABEL);
        o->minimum(-100);
        o->maximum(100);
        o->step(1);
        o->callback((Fl_Callback*)cb_xpan);
        o->align(FL_ALIGN_CENTER);
      }
      { Fl_Roller* o = vrot = new Fl_Roller(310, 505, 275, 20, "vrot");
        o->type(1);
        o->box(FL_PLASTIC_DOWN_BOX);
        o->minimum(-180);
        o->maximum(180);
        o->step(1);
        o->callback((Fl_Callback*)cb_vrot);
        o->align(FL_ALIGN_CENTER);
      }
      o->end();
    }
    viewer = new My3DView(220, 20, 440, 440, "vframe");
    { Fl_Group* o = hcontrol = new Fl_Group(670, 65, 65, 360, "hcontrol");
      o->labeltype(FL_NO_LABEL);
      o->align(FL_ALIGN_CENTER);
      { Fl_Slider* o = ypan = new Fl_Slider(685, 120, 20, 275, "ypan");
        o->type(4);
        o->box(FL_PLASTIC_DOWN_BOX);
        o->labeltype(FL_NO_LABEL);
        o->minimum(-100);
        o->maximum(100);
        o->step(1);
        o->callback((Fl_Callback*)cb_ypan);
        o->align(FL_ALIGN_CENTER);
      }
      { Fl_Roller* o = hrot = new Fl_Roller(705, 120, 20, 275, "hrot");
        o->box(FL_PLASTIC_DOWN_BOX);
        o->labeltype(FL_NO_LABEL);
        o->minimum(-180);
        o->maximum(180);
        o->step(1);
        o->callback((Fl_Callback*)cb_hrot);
        o->align(FL_ALIGN_CENTER);
      }
      o->end();
    }
    { Fl_Value_Slider* o = viewzoom = new Fl_Value_Slider(160, 40, 20, 270, "zoom");
      o->type(4);
      o->box(FL_PLASTIC_DOWN_BOX);
      o->minimum(1);
      o->maximum(50);
      o->step(0.1);
      o->value(10);
      o->callback((Fl_Callback*)cb_viewzoom);
    }
    o->end();
    o->resizable(o);
  }
  { Fl_Window* o = setting = new Fl_Window(196, 193, "Setting");
    w = o;
    o->user_data((void*)(this));
    { Fl_Group* o = iscolor = new Fl_Group(-5, 135, 205, 60);
      o->box(FL_DOWN_BOX);
      { Fl_Check_Button* o = rgb = new Fl_Check_Button(35, 150, 25, 25, "RGB");
        o->type(102);
        o->down_box(FL_DOWN_BOX);
        o->value(1);
      }
      { Fl_Check_Button* o = gray = new Fl_Check_Button(95, 150, 25, 25, "Grayvalue");
        o->type(102);
        o->down_box(FL_DOWN_BOX);
      }
      o->end();
    }
    { Fl_Value_Input* o = width = new Fl_Value_Input(65, 10, 85, 25, "Width:");
      o->maximum(400);
      o->value(256);
    }
    { Fl_Value_Input* o = height = new Fl_Value_Input(65, 50, 85, 25, "Height:");
      o->maximum(400);
      o->value(256);
    }
    { Fl_Value_Input* o = slice = new Fl_Value_Input(65, 90, 85, 25, "Slices:");
      o->maximum(400);
      o->value(1);
    }
    o->end();
  }
  { Fl_Window* o = gsetting = new Fl_Window(375, 460, "Gibbs Setting");
    w = o;
    o->box(FL_SHADOW_BOX);
    o->user_data((void*)(this));
    { Fl_Group* o = new Fl_Group(10, 15, 180, 100, "sampling");
      o->box(FL_DOWN_BOX);
      o->align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE);
      { Fl_Value_Input* o = radius = new Fl_Value_Input(80, 45, 100, 25, "Radius:");
        o->maximum(20);
        o->value(10);
      }
      { Fl_Value_Input* o = classnum = new Fl_Value_Input(80, 80, 100, 25, "Classes:");
        o->maximum(8);
        o->value(2);
      }
      o->end();
    }
    { Fl_Group* o = new Fl_Group(195, 15, 170, 100, "Gibbs Loop");
      o->box(FL_DOWN_FRAME);
      o->align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE);
      { Fl_Value_Input* o = step = new Fl_Value_Input(255, 45, 100, 25, "Steps:");
        o->maximum(100);
        o->value(1);
      }
      { Fl_Value_Input* o = errorrate = new Fl_Value_Input(255, 80, 100, 25, "Error:");
        o->maximum(25);
      }
      o->end();
    }
    { Fl_Group* o = new Fl_Group(10, 120, 355, 290, "Parameters");
      o->box(FL_DOWN_FRAME);
      o->align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE);
      { Fl_Value_Input* o = gradient = new Fl_Value_Input(80, 150, 100, 25, "Gradient:");
        o->maximum(20);
        o->value(6);
      }
      { Fl_Value_Input* o = regionlimit = new Fl_Value_Input(255, 150, 100, 25, "Region:");
        o->maximum(1000);
        o->value(100);
      }
      { Fl_Group* o = new Fl_Group(15, 180, 345, 85, "Weight I");
        o->box(FL_DOWN_FRAME);
        o->align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE);
        { Fl_Value_Slider* o = weight_grad = new Fl_Value_Slider(135, 205, 210, 20, "Gradient Weight");
          o->type(1);
          o->box(FL_PLASTIC_UP_BOX);
          o->align(FL_ALIGN_LEFT);
        }
        { Fl_Value_Slider* o = weight_gibbs = new Fl_Value_Slider(135, 235, 210, 20, "Gibbs Weight");
          o->type(1);
          o->box(FL_PLASTIC_UP_BOX);
          o->align(FL_ALIGN_LEFT);
        }
        o->end();
      }
      { Fl_Group* o = new Fl_Group(15, 270, 345, 135, "Boundary Weight");
        o->box(FL_DOWN_FRAME);
        o->align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE);
        { Fl_Value_Slider* o = weight_c1 = new Fl_Value_Slider(65, 305, 25, 90, "Type I");
          o->box(FL_PLASTIC_UP_BOX);
          o->align(FL_ALIGN_TOP_LEFT);
        }
        { Fl_Value_Slider* o = weight_c2 = new Fl_Value_Slider(120, 305, 25, 90, "Type II");
          o->box(FL_PLASTIC_UP_BOX);
          o->align(FL_ALIGN_TOP_LEFT);
        }
        { Fl_Value_Slider* o = weight_c3 = new Fl_Value_Slider(175, 305, 25, 90, "Type III");
          o->box(FL_PLASTIC_UP_BOX);
          o->align(FL_ALIGN_TOP_LEFT);
        }
        { Fl_Value_Slider* o = weight_c4 = new Fl_Value_Slider(230, 305, 25, 90, "Type IV");
          o->box(FL_PLASTIC_UP_BOX);
          o->align(FL_ALIGN_TOP_LEFT);
        }
        { Fl_Value_Slider* o = weight_o = new Fl_Value_Slider(285, 305, 25, 90, "Other");
          o->box(FL_PLASTIC_UP_BOX);
          o->align(FL_ALIGN_TOP_LEFT);
        }
        o->end();
      }
      o->end();
    }
    { Fl_Button* o = ok = new Fl_Button(150, 420, 100, 25, "Ok");
      o->callback((Fl_Callback*)cb_ok);
    }
    { Fl_Button* o = cancel = new Fl_Button(265, 420, 100, 25, "Cancel");
      o->callback((Fl_Callback*)cb_cancel);
    }
    o->end();
  }
  { Fl_Window* o = dfsetting = new Fl_Window(498, 232, "Deformable Model Setting");
    w = o;
    o->user_data((void*)(this));
    { Fl_Value_Input* o = maggradient = new Fl_Value_Input(375, 25, 100, 25, "Gradient Magnitude:");
      o->box(FL_PLASTIC_DOWN_BOX);
      o->maximum(20);
      o->value(1);
    }
    { Fl_Value_Input* o = scalex = new Fl_Value_Input(183, 65, 50, 25, "Scale X:");
      o->box(FL_PLASTIC_DOWN_BOX);
      o->maximum(20);
      o->value(1);
    }
    { Fl_Value_Input* o = vstiffness = new Fl_Value_Input(145, 145, 100, 25, "Vertical Stiffness:");
      o->box(FL_PLASTIC_DOWN_BOX);
      o->maximum(20);
      o->value(0.0001);
    }
    { Fl_Value_Input* o = hstiffness = new Fl_Value_Input(375, 145, 100, 25, "Hrizon Stiffness:");
      o->box(FL_PLASTIC_DOWN_BOX);
      o->maximum(20);
      o->value(0.04);
    }
    { Fl_Button* o = dfok = new Fl_Button(255, 185, 100, 25, "Ok");
      o->box(FL_PLASTIC_UP_BOX);
      o->callback((Fl_Callback*)cb_dfok);
    }
    { Fl_Button* o = dfcancel = new Fl_Button(375, 185, 100, 25, "Cancel");
      o->box(FL_PLASTIC_UP_BOX);
      o->callback((Fl_Callback*)cb_dfcancel);
    }
    { Fl_Value_Input* o = stepthreshold = new Fl_Value_Input(375, 105, 100, 25, "Step Threshold:");
      o->box(FL_PLASTIC_DOWN_BOX);
      o->maximum(20);
      o->value(30);
    }
    { Fl_Value_Input* o = timestep = new Fl_Value_Input(145, 105, 100, 25, "Time Step:");
      o->box(FL_PLASTIC_DOWN_BOX);
      o->maximum(20);
      o->value(0.001);
    }
    { Fl_Value_Input* o = scaley = new Fl_Value_Input(304, 65, 50, 25, "Scale Y:");
      o->box(FL_PLASTIC_DOWN_BOX);
      o->maximum(20);
      o->value(1);
    }
    { Fl_Value_Input* o = scalez = new Fl_Value_Input(425, 65, 50, 25, "Scale Z:");
      o->box(FL_PLASTIC_DOWN_BOX);
      o->maximum(20);
      o->value(1);
    }
    o->end();
  }
}

MyTestAppInterface::~MyTestAppInterface() {
}

void MyTestAppInterface::segment() {
  this->init();
  if ( !m_GibbsFilter ) m_GibbsFilter = GibbsFilterType::New();
  m_GibbsFilter->SetNumberOfClasses(m_ClassNum);
  m_GibbsFilter->SetMaximumNumberOfIterations(m_Step);
//  m_GibbsFilter->SetErrorTollerance(0.00);
  m_GibbsFilter->SetClusterSize(m_Region);
  m_GibbsFilter->SetBoundaryGradient(m_Gradient);
  m_GibbsFilter->SetObjectLabel(1);
 
  m_GibbsFilter->SetInput(m_DataImage);
  m_GibbsFilter->SetClassifier( myClassifier ); 

  //Since a suvervised classifier is used, it requires a training image
  m_GibbsFilter->SetTrainingImage(m_ClassImage);  

  //Kick off the Gibbs labeller function
  m_GibbsFilter->Modified();
  m_GibbsFilter->Update();
}

void MyTestAppInterface::display() {
  this->ShowResult();
}

void MyTestAppInterface::Show() {
  mainwin->show();
}

void MyTestAppInterface::init() {
  //create the initial class image
  m_ClassImage = ImageType3D::New();
  ImageType3D::SizeType  classImgSize = {{cols, rows, 1}};
  ImageType3D::IndexType classindex;
  classindex.Fill(0);
  ImageType3D::RegionType classregion;

  classregion.SetSize(classImgSize);
  classregion.SetIndex(classindex);

  m_ClassImage->SetLargestPossibleRegion(classregion);
  m_ClassImage->SetBufferedRegion(classregion);
  m_ClassImage->Allocate();

  // setup the iterators
  typedef  itk::ImageRegionIteratorWithIndex<ImageType3D>  ClassImageIterator;

  ClassImageIterator classIt( m_ClassImage, m_ClassImage->GetBufferedRegion() );
  classIt.GoToBegin();

  //--------------------------------------------------------------------------

  unsigned int numPoints=m_Viewer->numClickedPointsStored();
  ClickPoint *point;

  int i = 0;
  while ( !classIt.IsAtEnd() ) {
    classIt.Set(0);  
    for ( int j = 0; j < numPoints; j++ ) {
      point=m_Viewer->getClickedPoint(j);
      if (((i%cols-(int)(point->x))*(i%cols-(int)(point->x))+
        (i/cols-((int)point->y))*(i/cols-(int)(point->y))) < m_Radius*m_Radius) 
        classIt.Set(j+1);
    }

    ++classIt;
    i++;
  }

//setup the classifier
  applyEstimateModel = ImageGaussianModelEstimatorType::New();

  applyEstimateModel->SetNumberOfModels(m_ClassNum);
  applyEstimateModel->SetInputImage(m_DataImage);
  applyEstimateModel->SetTrainingImage(m_ClassImage);
  applyEstimateModel->Update();

  membershipFunctions = applyEstimateModel->GetMembershipFunctions();

  if (!myDecisionRule) myDecisionRule = DecisionRuleType::New();

//  if ( myClassifier ) delete myClassifier;
  myClassifier = ClassifierType::New();

  myClassifier->SetNumberOfClasses(m_ClassNum);
  myClassifier->SetDecisionRule((DecisionRuleBasePointer) myDecisionRule);
  for ( i=0; i<m_ClassNum; i++ ) 
    myClassifier->AddMembershipFunction(membershipFunctions[i]);
}

void MyTestAppInterface::setpar() {
  gsetting->show();
}
